//! This module provides the `SaveLastAnswerCommand`, which facilitates the retrieval and saving
//! of the last message generated by the AI assistant in a chat session. This command is useful
//! for users who want to keep a record of the assistant's responses for future reference,
//! documentation, or further action.
//!
//! The command checks if there is a last assistant message available and allows the user to
//! save it to a specified file. If the user does not provide a filename, it defaults to
//! "last_answer.txt". Users are prompted for a file path where the content will be saved.
//! If no assistant message exists, the command will inform the user accordingly.
//!
//! ## Usage Example
//!
//! To register this command with a command registry:
//! ```
//! let mut registry = CommandRegistry::new();
//! SaveLastAnswerCommand::register_with_registry(&mut registry);
//! ```
//!
//! To execute the command, you can simply call:
//! ```
//! let save_command = SaveLastAnswerCommand::new();
//! save_command.execute(&[], &mut chat_service).unwrap();
//! ```
//!
//! The above code will prompt for the desired file path and handle the save operation.
//!
//! # Implementation Details
//!
//! The command relies on the `find_last_assistant_message` helper function to retrieve the
//! most recent message delivered by the assistant. It uses file I/O operations provided
//! by Rust's standard library to write the content to a specified file path.
//!
//! Error handling is integrated to manage scenarios where file writing may fail
//! due to invalid paths or permission issues. It ensures a smooth user experience by
//! providing feedback messages based on the outcome of the operation.

use crate::cli::editor::get_filename_input;
use rbchat::chat::command::{ChatCommand, RegisterableCommand};
use rbchat::chat::command_registry::CommandRegistry;
use rbchat::chat::message_helpers::find_last_assistant_message;
use rbchat::chat::service::ChatService;
use std::error::Error;
use std::fs;

/// SaveLastAnswerCommand retrieves the last answer provided by the assistant
/// and saves it to a specified file. If no filename is provided, it defaults
/// to "last_answer.txt". This command checks for an existing assistant message
/// to ensure that it has something to save.
pub struct SaveLastAnswerCommand;

impl SaveLastAnswerCommand {
    pub fn new() -> Self {
        SaveLastAnswerCommand {}
    }
}

impl ChatCommand for SaveLastAnswerCommand {
    fn execute(
        &self,
        _args: &[&str],
        chat_service: &mut ChatService,
    ) -> Result<(), Box<dyn Error>> {
        if let Some(last_message) = find_last_assistant_message(chat_service) {
            let default_file_name = "last_answer.txt";
            let user_file_path = get_filename_input(&format!(
                "Enter file path to save the last answer (default: {}). Use <Tab> for filename autocompletion: ",
                default_file_name
            ))?;

            let file_path = if user_file_path.trim().is_empty() {
                default_file_name.to_string()
            } else {
                user_file_path
            };

            fs::write(&file_path, last_message)?;
            println!("Last assistant answer saved to '{}'.", file_path);
        } else {
            println!("No assistant answer to save.");
        }

        Ok(())
    }
}

impl RegisterableCommand for SaveLastAnswerCommand {
    fn register_with_registry(registry: &mut CommandRegistry) {
        let command = SaveLastAnswerCommand::new();
        registry.register_command(
            "/save-last-answer",
            Box::new(command),
            vec!["save-last-answer".to_string()],
        );
    }
}
